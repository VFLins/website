title: Concluindo a primeira vers√£o do front-end do Cashd com Toga
---
pub_date: 2025-08-06
---
tags:

Cashd
Novo recurso
---
body:


<blockquote class="callout-success">

    <p><b>‚úÖ O <i>layout</i> inicial do aplicativo do Cashd est√° finalizado</b></p>
    
    <p>Agora temos formul√°rios em duas colunas, al√©m de espa√ßamentos e alinhamentos
    padronizados. Isto conclui a segunda tarefa de: <a href="../2025-06-16/">"Melhorar
    interface, aumentar a largura do conte√∫do e organizar inputs em duas colunas"</a>.</p>

</blockquote>

## Introduzindo `FormHandler`

Tr√™s classes foram adicionadas para lidar com a cria√ß√£o din√¢mica de formul√°rios:

1. `FormField`, que representa um campo, o menor elemento de um formul√°rio, e cont√©m
um dos *inputs* que ser√£o fornecidos pelo usu√°rio;
2. `FormRow`, uma combina√ß√£o de campos dispostos horizontalmente, ele deve controlar a
quantidade de colunas exibidas, a largura do formul√°rio, e a largura m√°xima de cada um
de seus campos;
3. `FormHandler`, possui uma propriedade `full_contents` onde ficam os conte√∫dos de todos
os seus `FormRow`. Ele oferece uma interface para os dados preenchidos pelo usu√°rio e
lida com a inclus√£o e remo√ß√£o de campos, al√©m dos eventos `on_change`, `on_lose_focus`,
etc.

### Os campos do formul√°rio

Uma inst√¢ncia da nova classe `FormField` retorna um `toga.Box` modificado, essencialmente
com tr√™s elementos:

1. Um r√≥tulo (`label`), com um t√≠tulo para o campo;
2. Um *widget* de *input* (`input_widget`), onde o usu√°rio vai inserir a informa√ß√£o;
3. Uma descri√ß√£o opcional (`annotation`), um texto curto abaixo do `input_widget` com
  mais informa√ß√µes para o usu√°rio.

Outro atributo tamb√©m importante, mas n√£o essencial √© o `id`, que √© usado para
identificar cada *input* com uma *string* √∫nica, o `FormField` definido com o id
`"my_field"` poder√° ser obtido do `FormHandler`:

```python
from cashd.wigets.form import (
    FormHandler,
    FormField
)
from toga import TextInput

form = FormHandler()
field = FormField(
    label="My field",
    input_widget=TextInput(),
    id="my_field",
    required=False,
)

form.add_fields([field])
"""Adicionar o FormField ao FormHandler."""

form.fields["my_field"]
"""Acessar o FormField."""

form.fields["my_field"].input_widget.value
"""Dado inserido pelo usu√°rio."""
```

Repare que tamb√©m existe um par√¢metro `required` ao definir o `FormField`, ele ser√°
explicado mais adiante, no t√≥pico "O manipulador de formul√°rios". Mas antes, vamos falar
sobre o que se espera das linhas do formul√°rio.

### As linhas do formul√°rio

Atualmente, para fim de simplicidade e velocidade de implementa√ß√£o, `FormRow` apenas
possuem uma largura fixa, n√£o se adaptando √† largura da janela, e n√£o aceita mais que
dois campos, com uma largura m√°xima fixada.

A largura dos campos atualmente est√° sendo gerenciada fora de `FormRow`, com a fun√ß√£o
`cashd.style.user_input()`, que recebe um tipo de *input* como `toga.TextInput` e retorna
o `toga.style.Pack` padr√£o correspondente.

Mas no caso de uma implementa√ß√£o para dispositivos m√≥veis, onde a largura da tela depende
da orienta√ß√£o do aparelho, seria necess√°rio que `FormHandler` tivesse um 
*event listener*, que automaticamente ativaria a rotina de reorganiza√ß√£o dos campos em um
novo conjunto de `FormRow`, aumentando ou diminuindo a quantidade de *inputs* por linha.

### O manipulador de formul√°rios

O `FormHandler` √© respons√°vel por organizar os campos do formul√°rio em uma grade
orientada √† linhas de *inputs*. Ele tamb√©m √© respons√°vel por passar uma fun√ß√£o que se
ative sempre que algum tipo de intera√ß√£o ocorre com o input, como `on_change` ou
`on_lose_focus`, todos os campos recebem a mesma fun√ß√£o, portanto, para oferecer
tratamentos distintos para cada uma, seria necess√°rio acessar os metadados de cada campo.

Atualmente, para as necessidades do [Cashd](../../tag/Cashd), o √∫nico metadado que precisa ser acessado
√© o fato de o preenchimento de determinado campo √© obrigat√≥rio ou n√£o, isto √© passado
para cada `FormField` individualmente, com o valor padr√£o `False`. Ainda √© poss√≠vel
verificar se todos os campos obrigat√≥rios foram preenchidos usando o m√©todo
`required_fields_are_filled()`:

```python
from cashd.widgets.form import FormHandler
from cashd.data import get_default_customer

customer = get_default_customer()
"""Inst√¢ncia de cashd.data.tbl_clientes
com alguns valores preenchidos.
"""
form = FormHandler()

form.add_table_fields(table=customer)
"""Adicionar campos da tabela 'clientes'."""

def on_change_form(widget):
	required_filled = form.required_fields_are_filled()
	"""Verificar se todos os campos obrigat√≥rios
	foram preenchidos.
	"""
	if required_filled:
		print("Required fields are filled!")
	else:
		print("Some required fields are still empty.")

form.on_change = on_change_form
```

Veja que tamb√©m podemos preencher um formul√°rio com todos os campos da tabela clientes
rapidamente, isto tamb√©m preenche os campos com os valores de `customer`, define o `id`
de cada campo com o nome de sua respectiva coluna no banco de dados, o `label` com o
respectivo `display_name` definido em `cashd.data.tbl_clientes`, e o metadado `required`
de acordo com o [[2025-07-08#1.1 A valida√ß√£o de dados agora √© feita pelo `sqlalchemy`|tipo de dados declarado ao SQLAlchemy]].


O exemplo de c√≥digo acima funciona adequadamente quando recebe uma inst√¢ncia de
`cashd.data.tbl_clientes`, mas atualmente ainda n√£o consegue lidar com
`cashd.data.tbl_transacoes`, porque ainda n√£o foi instru√≠do sobre como lidar com campos
de data.

## Melhorias visuais e de experi√™ncia do usu√°rio

Todas as telas exceto a de estat√≠sticas passaram por melhorias visuais, vamos mostrar
por ordem:

### Tela inicial

A tela inicial n√£o possui mais os tr√™s bot√µes, em que cada um levaria √† uma intera√ß√£o
diferente, agora, em vez disso, apenas um bot√£o leva para um `toga.OptionContainer`,
que mostra um conjunto de abas que mostra todas as intera√ß√µes poss√≠veis com o usu√°rios
selecionado.

![Tela inicial do Cahsd, "Selecionar cliente".](cashd-selecionar_cliente-winforms.png)
 
Ao clicar no √≠cone de usu√°rio com uma caneta, vamos para uma tela com todas as op√ß√µes
que antes estavam dispostas em bot√µes, agora dispostas em abas. Todas as intera√ß√µes
feitas dentro deste conjunto de abas ser√£o aplicadas ao usu√°rio informado na parte
superior.

![Tela inicial do Cashd, "Inserir transa√ß√£o".](cashd-transacoes_nova_transacao-winforms.png)

Esta √© a tela de hist√≥rico de transa√ß√µes:

![Tela inicial do Cashd, "Hist√≥rico de transa√ß√µes".](cashd-transacoes_historico-winforms.png)

Para habilitar o bot√£o "Remover transa√ß√£o", o usu√°rio deve primeiro selecionar
alguma linha da tabela, ao remover uma transa√ß√£o, o usu√°rio recebe um di√°logo de
confirma√ß√£o, que informa qual transa√ß√£o ser√° exclu√≠da. Ao confirmar, esta transa√ß√£o ser√°
removida, e as informa√ß√µes na parte superior ser√£o atualizadas.

![Di√°logo de confirma√ß√£o, "Remover transa√ß√£o?".](cashd-confirma_remover_transacao-winforms.png)

J√° na aba "Informa√ß√µes do cliente" √© poss√≠vel ver as informa√ß√µes de cadastro atuais do
cliente selecionado, e modific√°-las:

![Tela inicial do Cashd, informa√ß√µes do cliente selecionado.](cashd-transacoes_informacoes-winforms.png)

A tela acima j√° segue o *layout* padr√£o de formul√°rios definido pelo `FormHandler`
mencionado anteriormente, mas este n√£o √© o √∫nico lugar onde esse *layout* √© aplicado.

### Telas "Novo cliente" e "Configura√ß√µes"

As telas "Novo Cliente" e "Configura√ß√µes" tamb√©m seguem o novo *layout* de duas colunas
implementados com `FormHandler`:

![Tela "Novo cliente" do Cahsd.](cashd-novo_cliente-winforms.png)

![Tela de Configura√ß√µes do Cashd.](cashd-configuracoes-winforms.png)

## Migrando as duas vers√µes do Cashd para um √∫nico reposit√≥rio

At√© o momento, os dois projetos foram desenvolvidos em reposit√≥rios separados, um aberto
chamado `cashd`, onde est√° o projeto desenvolvido com Taipy, que pode servir um √∫nico app
web para uma rede local, que pode ser acessado apenas no pr√≥prio computador, ou em
qualquer n√∫mero de computadores conectados na rede local. E outro reposit√≥rio
`cashd-cross`, fechado, onde eu desenvolvo o aplicativo *stand-alone* e independente de
rede, que pode ser compilado para qualquer plataforma atual, seja *mobile* ou para
computador de mesa (*cross-platform*, da√≠ o nome).

A pr√≥xima coisa a ser feita neste projeto √© unir ambas as implementa√ß√µes em um s√≥
reposit√≥rio, reservando um
*[namespace](https://packaging.python.org/en/latest/guides/packaging-namespace-packages/#native-namespace-packages)*
para cada projeto. Al√©m disso, existem outras coisas pertinentes para se adicionar √†
lista de coisas a fazer:

> üìù **Tarefa pendente:** Agregar os reposit√≥rios `cashd` e `cashd-cross` + Adaptar `cashd` com Taipy para agir como servidor.
>	- Preparar o primeiro *release* do `cashd-cross` e uma rotina p√∫blica de *build* para os seus bin√°rios;
>	- Mudar os nomes de cada projeto para `cashd-server` e `cashd-local`;
>	- Mudar o foco do `cashd-server` para agir como servidor, em vez de fazer parecer um programa local usando um *webview*.
